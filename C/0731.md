### 나머지 연산자

```c
#include <stdio.h>

int main()
{
	int seconds = 0, minutes = 0, hours = 0;
	
	//while문만 사용할 때는 음수를 넣은 것을 실행하지 않기 위해 이 방법만 쓸 수 있다.
	printf("Input seconds : ");
	scanf("%d", $seconds);

	while(seconds >= 0)
	{
		minutes = seconds / 60;
		seconds %= 60;
	
		hours = minutes / 60;
		minutes %= 60;
	
		//print result
		printf("%d hours, %d minutes, %d seconds\n", hours, minutes, seconds);

		printf("Input seconds : ");
		scanf("%d", $seconds);
	}

	printf("Good bye\n");

	int div, mod;

	//음수를 나눌 때 규칙은 앞에 피연산자가 음수면 나머지 연산 결과도 음수
	div = 11 / 5;
	mod = 11 % 5;
	printf("%d %d, div, mod); // 2, 1

	div = -11 / -5;
	mod = 11 % -5;
	printf("%d %d, div, mod); // -2 1

	div = -11 / -5;
	mod = -11 % -5; // first operand is negative
	printf("%d %d, div, mod); // 2 -1

	div = -11 / 5;
	mod = -11 % 5; // first operand is negative
	printf("%d %d, div, mod); // -2 -1

	return 0;

}
```

### 증가/감소 연산자

```c
#include <stdio.h>

int main()
{
	int a = 0;
	a++; // a = a + 1 or a += 1; postfix 후위
	printf("%d\n", a);

	++a; // a = a + 1 or a += 1; prefix 전위
	printf("%d\n", a);

	double b = 0;
	b++;
	printf("%f\n", b);

	++b;
	printf("%f\n", b);

	int count = 0;
	while (count < 10) // ++count or count++
	{
		// ++count or count ++;
		printf("%d ", ++count); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
		printf("%d ", count++); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
	}

	int i = 1, j = 1;
	int i_post, pre_j;

	i_post = i++;
	pre_j = ++j;

	printf("%d %d\n", i, j); // 2 2
	printf("%d %d\n", i_post, pre_j); // 1 2

	int i = 3;
	int l = 2 * --i;
	printf("%d %d\n", i, l); // 2 4

	i = 1;
	l = 2 * i--;
	printf("%d %d\n", i, l); // 0 2

	/* very high precedence */
	int x, y, z;
	x = 3, y = 4;
	z = (x + y++) * 5;
	printf("%d %d %d", x, y, z); // 3 5 35

	/* ++ and -- affect modifiable lvaues */
	int x = 1, y = 1, z;
	z = x * y++; // (x) * (y++), not (x*y)++
	z = (x * y)++; //error , x * y가 수정가능한 lvalue가 아님
	z = 3++; // error

	/* Bad practices */
	int n = 1;
	printf("%d %d", n, n * n++); // 값이 컴파일러마다 다르게 나올 수도 있음 쓰지 마셈
	int x = n / 2 + 5 * (1 + n++); // 이런건 나눠서 쓰자
	int y = n++ + n++;

	return 0;
}
```

---

## 표현식(Expressions)과 문장(Statements)

- 표현식은 값을 계산해 낸다
- c/c++에서는 문장 끝에 세미콜론을 넣어서 마친다
- 대부분의 경우 Sequence points는 세미콜론이고 여기서 앞에 표현식의 값을 계산한다

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/895366ee-ba0e-44ae-b173-5d2f4ce14126/_2020-07-31__3.29.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/895366ee-ba0e-44ae-b173-5d2f4ce14126/_2020-07-31__3.29.17.png)

- `y = (4 + x++) + (6 + x++);` 괄호 안이 다 full expression이 아니기 때문에 언제 계산될 지 알기 어렵고 그래서 한 문장 안에서 여러개 쓰이면 연산의 결과를 예상하기 어렵다

---

## 자료형 변환

```c
#include <stdio.h>

int main()
{
	/* promotions in assignments */
	// 작은 것을 큰 것에 넣으면 문제가 안생김
	short s = 64;
	int i = s;

	float f = 3.14f;
	double d = f;

	/* demotion in assignments */
	// truncation 경고!
	d = 1.25;
	f = 1.25; // f가 없는 경우 double 1.25는 float로도 정밀하게 나타낼 수 있어서 경고가 없음(컴파일러마다 다를 수도 있는 특징)
	f = 1.123;
	
	/* ranking of types in operations */
	// long double > double > float
	// unsigned long long, long long
	// unsigned long, long
	// unsigned, int
	// short int, unsigned shord int
	// signed char, char, unsigned char
	// _Bool
	// Ref: Google "integer conversion rank'
	d = f + 1.234; // double로 바꿔서 double + double
	f = f + 1.234; // double로 바꿔서 double + double 값도 double 나옴 f에 넣으려면 경고

	/* automatic promotion of function arguments */
	// 1. Functions without prototypes;
	// 2. Variadic function (ellipsis)

	/* casting operators */
	/* 프로그래머의 의도를 정확히 표현해주는 이런 방법이 좋음 */
	d = (double)3.14f;
	i = 1.6 + 1.7; // 3
	i = (int)1.6 + (int)1.7; // 2

	/* more examples */
	char c;
	int i;
	float f;
	f = i = c = 'A'; // 65
	printf("%c %d %f\n", c, i, f); // A 65 65.00000
	c = c + 2; // 'C', 67
	i = f + 2 * c; // 65.0f + 2 * 67
	printf("%c %d %f\n", c, i, f); // C 199 65.00000
	c = 1106; // demolition, 1106 = 0b10001010010, 0b01010010 = 1106 % 256 = 82 = 'R'
	printf("%c\n", c);
	c = 83.99;
	printf("%c\n", c); // S

	return 0;
}
```

---

## 함수의 인수와 매개변수

```c
#include <stdio.h>

void drow(int n); // ANSI function prototype declaration

int main()
{
	int i = 5;
	char c = '#'; // 35
	float f = 7.1f;

	draw(i);
	draw(int(c)); // 승격은 문법상 문제가 없지만 확실한 표현
	draw(f); // 경고!!
	draw((int)f);

	/* Arguments vs. Parameters */
	// actual argument, actual parameter -> argument (values)
	// formal argument, formal parameter -> parameter (variables)
	
	return 0;
}

void drow(int n)
{
	/* count = 0;
	while(count < n)
	{
		printf("*");
		count++;
	} */
	while (n-- > 0)
		printf("*");
	printf("\n");
}
```

---

## while 반복 루프에서 scanf()의 반환값 사용하기

```c
#include <stdio.h>

int main()
{
	int num, sum = 0;
	int status;
	
	printf("Enter an integer (q to quit) : ");
	// 정수가 아닌 값이 들어온다면 0을 return 할 것임
	stauts = scanf("%i", &num); // return value of scanf()

	while(status == 1) // equality operator
	{
    sum += num;

    printf("Enter an integer (q to quit) : ");
	  status = scanf("%i", &num);
    
	}
  
  printf("Sum = %d\n", sum);

	// C-style shortcut

	return 0;
}
```

```c
// C-style shortcut
#include <stdio.h>

int main()
{
	int num, sum = 0;
	
	printf("Enter an integer (q to quit) : ");

	while(scanf("%d", &num) == 1) // equality operator
	{
    sum += num;

    printf("Enter an integer (q to quit) : ");
	}
  
  printf("Sum = %d\n", sum);

	return 0;
}

```

---

## 진입조건 루프 while

```c
#include <stdio.h>

int main()
{
	/*
	while (expression)
		statement
	*/

	int i;

	i = 1;
	while (i < 5) // infinite loop
		printf("Hi!\n"); // iteration

	i = 1;
	while(--i < 5) // wrong direction
		printf("Hi!\n");

	i = 1;
	while (i < 5)
	{
		printf("i before = %d\n", i);
		i++;
		printf("i after = %d\n", i);
	}

	i = 10;
	while (i++ < 5) // cannot enter
	{
		printf("Hi\n");
	}

	/* Common mistakes */

	i = 0;
	while (i < 3)
		printf("%i\n", i);
		i++; // indenting

	i = 0;
	while (i++ < 3); // null statement
		printf("%i\n", i);

	// 의도적으로 이렇게 작동할 때도 있음 숫자가 아닐때까지 계속 입력 받게 함
	// 하지만 현재는 컴퓨터가 좋아졌기 때문에 암호문같은 코드보다는 보기 좋은 코드
	while (scanf("%d, &i) == 1)
		; // null statement
	// do something (?)

	return 0;
}
```

## 관계 연산자

```c
#include <stdio.h>
#include <math.h> // fabs() 절댓값

int main()
{
	/*
		Relational Operators
		<    is less than
		<=   is less than or equal to
		==   is equal to
		>=   is greater than or equal to
		>    is greater than
		!=   is not equal to	
	*/

	int n = 0;
	while (n++ < 5) // n++ < 5 is a relational expression
		printf("%d ", n);

	printf("\n");

	char c = 'A';
	while (c != 'Z')
		printf("%c ", c++);

	const double PI = 3.1415926535897932384626433832795;
	double guess = 0.0;

	printf("Input pi : ");
	scanf("%lf", &guess);
	//실수끼리 비교할 때는 같냐 다르냐는 민감한 문제일 수 있음 그래서 적당한 선에서 조절하기 위해 바꿔서 구현
	//while (guess != PI) // 실수에서는 != 잘 안씀
	while(fabs(guess - PI) > 0.01) 
	{
		printf("Fool! Try again.\n");
		scanf("%lf", &guess);
	}

	printf("Good!");

	return 0;
}
```
