> 따라하며 배우는 C언어

C언어를 제대로 배워보고 C++의 기반이 되도록 하며 자료구조와 알고리즘을 공부하는데 도움이 될 수 있도록 해보자 😜

## 컴퓨터의 구성요소

### 메인보드

### 중앙 처리장치 - Central Processing Unit(CPU)

### 주 기억장치 - Primary Storage(Computer Memory)

- Random Access Memory(RAM) - 전원을 끄면 데이터가 사라짐

### 보조 기억장치

- HDD - FDD에 비해 딱딱해서 HDD ㅋㅋ
- SSD
- FDD - 안에 디스크가 돌면서 데이터 찾음(HDD도 비슷), 전통적으로 A,B 디스크가 FDD여서 현재도 C로 시작
- 자기 태이프

### 그래픽 카드

- 그래픽 카드 안에 CPU가 GPU
- 그래픽 카드 용도의 메모리도 들어있음
- 두 가지의 스팩으로 가격이 달라짐

### 입출력 장치

### 전원 공급장치

### 디스플레이

---

## 컴퓨터를 켤 때 일어나는 일들

### 부팅 절차

1. 전원 공급장치 메인보드에 전원 공급
2. 부팅 프로그램 실행
3. 하드웨어 검사
4. 운영 체제 로드
5. 운영 체제 실행

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/024453c6-4107-4b78-ae7e-1f402d2bebb6/_2020-07-22__4.40.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/024453c6-4107-4b78-ae7e-1f402d2bebb6/_2020-07-22__4.40.08.png)

- ROM은 이미 정해져 있고 읽을 수 만 있음
- ROM BIOS는 부트 프로그램에 대한 것들이 실행되는 것
- 운영 체제도 프로그램
- CPU는 기능을 담당 기억 저장하는 곳이 아님
- 정보를 담는 것은 두 기억 장치
- 운영체제는 보조 기억 장치에 저장되어 있음
- CPU는 보조 기억 장치를 직접 접근할 수 없음
- CPU는 주 기억 장치와 소통함
- 보조 기억 장치의 프로그램을 주 기억 장치에 복사하고 CPU가 실행함
- 운영 체제 로드 = 보조 기억 장치 → 주 기억 장치
- 운영 체제 실행 = CPU가 실행함

---

## 운영체제가 해주는 일들

- 운영체제는 여러가지 일을 하는데 도움을 준다
- 운영체제의 종류 - 유닉스, 리눅스, 윈도우, Mac OS, IOS, 안드로이드 등
- OS의 핵심 기능은 비슷함

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32e6ca14-88e5-4b76-a7ed-4dd3f6fdbdda/_2020-07-22__4.50.59.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32e6ca14-88e5-4b76-a7ed-4dd3f6fdbdda/_2020-07-22__4.50.59.png)

- 하드웨어를 조작하는 법을 항상 만들어야 한다면 너무 오래 걸림
- 공통으로 개발해야 하는 부분을 묶어서 개발하자는 것이 운영체제의 시작
- 하드웨어를 어떻게 사용할 지 운영체제 만드는 사람들이 미리 만들어서 제공하는 것
- 하드웨어를 다루는 중요한 부분을 커널이라고 함
- 여러 프로그램들이 작동할 때 메모리를 사용할지 결정하고 자원을 관리하는 것이 운영체제의 중요한 역할 중 하나

---

## 컴퓨터는 왜 2진수를 사용할까?

> 뛰어난 프로그래머가 되는 것은 사람과 컴퓨터의 생각의 차이를 이해했다고 볼 수 있다.

### 컴퓨터는 다양한 정보를 숫자로 바꿔서 저장한다

- 컴퓨터는 이진법을 사용
- 0, 1을 사용하는 이유는 에디슨 효과(리처드슨 효과, 열전자 방출)에서 가져옴 🤢
- 최초의 컴퓨터 애니악 진공관을 가짐(크고 에디슨 효과를 위해 열을 내야 함)
- Bell 연구소에서 트랜지스터가 나오며 정보기술이 현저한 발전을 함
- 트랜지스터는 진공관과 거의 비슷한 기능을 하지만 훨씬 작고 안정적으로 작동함
- 트랜지스터 아주 작게 만들어서 많이 쑤셔 넣으면 집적 회로가 됨( i7에 트랜지스터 11억 6천개 들어감 ㅋㅋㅋㅋ)

---

## 현대적 컴퓨터의 기본 구조

### 앨런 튜링

- Universal Turing machine - 이 개념이 이후 확장이 되게 됨

### 폰 노이만

- 현대의 컴퓨터 구조를 제시
- 핵폭탄을 만들기 위해 계산이 너무 많이 들어서 컴퓨터 만들기로 함
- 내장형 프로그램 방식의 컴퓨터 = 폰 노이만 구조
- 제시한 것은 폰 노이만이지만 여러 엔지니어들이 컴퓨터를 업데이트한 것
- 입력을 받고 입력에 의한 올바른 출력을 내보내는 것이 컴퓨터
- 프로그램이 메모리에 들어가게 됨
- CPU안에는 컨트롤 유닛과 논리/연산 유닛으로 나눠져 있음

---

## 컴퓨터 메모리의 기본 구조

- 순차 접근 vs 임의 접근
- 현대의 컴퓨터에서는 임의 접근을 사용
- 램은 내부적으로 임의 접근을 잘 할 수 있도록 만들어져 있음
- 램 안의 셀 하나에 1 bit(0 or 1)이 저장됨
- CPU와 RAM은 연결되어 있음
- 데이터를 임의 접근 할 수 있도록 address bus와 data bus가 따로 나눠져 있음
- 엄밀히 말하면 주소 버스는 CPU → RAM 으로 감
- control bus가 보낼 건지 받을 건지 정하는 버스
- CPU가 어느 주소에 데이터를 쓰거나 저장하라 하면 메모리가 그것을 수행
- 포인터가 있는 이유는 address bus 때문에 있는 것 🤭

---

## CPU의 기본 구조

### 프로그램이 시작되는 과정

- 프로그램은 보조기억장치에 먼저 저장
- 실행하고 싶을 때는 운영체제에 부탁하는 것
- 사용자에게 프로그램을 실행하라는 입력을 받으면 보조기억장치 속의 프로그램을 주기억장치에 복사
- 프로그램은 CPU가 무슨 일을 하라고 할 지 기록한 것

### CPU의 언어는 무엇일까

- CPU가 사용하는 언어는 이진수로 이뤄진 기계어(Machine code) = 사람이 하기 굉장히 어려움
- 기계어보다 사람에게 좀 더 가까운 언어 Assembly language
- 기계어를 사람이 이해할 수 있는 언어로 바꿔둠(Mnemonic)
- CPU가 가진 명령어 집합을 합쳐서 거대한 프로그램을 만드는 것

### CPU의 구성요소

- 제어 장치(Control Unit) - 어떤 일을 할 때 제어해주는 일을 함
- 산술 논리 장치(Arithmetic Logic Unit) - 실제 컴퓨터의 계산 부분
- 여러가지 레지스터들(Registers) - ALU가 일을 하는 책상 같은 곳
    - 주소 레지스터 - 읽거나 쓸 메모리 주소 저장
    - 프로그램 카운터 - 다음 명령어의 메모리 주소 저장
    - 데이터 레지스터 - 메모리에서 읽어온 데이터 저장
    - 명령어 레지스터 - 메모리에서 읽어온 명령어 저장
    - 어큐뮬레이터 - 연산에 사용되는 데이터 저장
- 레지스터와 메모리는 구분하는 것이 좋다

---

## CPU가 일하는 방법

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/82614791-0ee5-44a4-8ab3-db001e125f00/_2020-07-22__5.51.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/82614791-0ee5-44a4-8ab3-db001e125f00/_2020-07-22__5.51.58.png)

- A의 주소 10, B의 주소 11
- 10번지 데이터를 가져오고 11번지 데이터를 더해서 그 결과를 12번지에 넣어라

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c984bf77-4fbd-4878-898b-eeae1b569cfc/_2020-07-22__5.55.26.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c984bf77-4fbd-4878-898b-eeae1b569cfc/_2020-07-22__5.55.26.png)

- PC에 프로그램 첫번째 명령어가 어느 주소에 있는지 넣음(운영체제가 함)
- PC는 항상 이 CPU가 실행시킬 다음번 명령어의 주소를 가르키게 되어 있음
- 시작점이 필요하다는 개념은 프로그래머들에게 꼭 도움이 되는 개념
- CPU의 동작

---

## 정보의 단위

- 정보의 기본 단위 = 비트(binary digit) = 0 or 1
- 메모리 주소의 기본 단위 = 1 바이트 byte = 8 비트
- CPU가 데이터를 다루는 기본 단위(레지스터 크기) = 16비트 워드 word 또는 32비트 워드

### 데이터 vs 정보

- 데이터는 측정이나 관찰을 통해 얻는 값
- 정보는 데이터 처리 과정을 거쳐 쓸모 있는 유용한 형태로 바꾼 것

---
## C 언어의 탄생

- 유닉스 운영체제를 어셈블리 언어로 만들다 C언어를 만들었다

---

## C언어의 특징

### C 언어의 장점

- 프로그램의 효율성을 높일 수 있다
- 강력하면서도 유연하다
- 프로그래머 중심이다(C/C++ 둘다 가진 장점)
- 다른 시스템으로 이식하기 좋다
- 운영체제를 만들기 위해 사용한 언어이기 때문에 강력 🥴
- 현대 프로그래밍 관점에서 c언어를 모든 곳에 쓰는 것은 생산성에 맞지 않기 때문에 필요한 곳에 쓰는 것

### C언어의 단점

- C를 사용할 때는 주의를 많이 기울이자

### C언어가 쓰이는 곳

- 컴퓨터가 쓰이는 모든 곳

### C언어는 어디로 가는가?

- 좋은 경력을 가진 프로그래머들은 무엇을 공부하셨는가?
- 현업에서 다른 것을 쓰더라도 C++은 거쳐가기 마련

---

## C 언어의 표준

### K&R C(Classic C)

- 유닉스와 함께 제공된 라이브러리가 사실상의 표준

### The Spirit of C(C89, C90)

- 프로그래머를 믿어라
- 프로그래머가 필요한 일을 하는 것을 방해하지 마라
- 언어를 작고 단순하게 유지해라
- 한 연산을 할 때 단 한 가지 방법만 제공해라
- 호환을 보장할 수 없다 하더라도 속도를 빠르게 해라

### ANSI/ISO C9X Committee

- 국제적인 문자 집합 추가
- 64비트 프로세서 대응
- 과학 공학 수치 계산 적합도 개선(FORTRAN 대체)
- 언어를 단순하게 유지
- 

> "커미티는 (c가 아니라) C++가 크고 야심찬 언어가 되는 것을 허용하는 것에 동의했다"

### The C11 Standard

- C99의 일부를 선택적인 기능으로 변경(표준을 줄이면 여러 시스템에서 자신에게 맞게 최적화하기 좋기 때문)
- 멀티 프로세서 대응 concurrent programming

### The C18 Standard

- 새로운 기능 추가 없이 C11의 결함 수정

---

## 소프트웨어 개발의 7가지 단계

1. 목적을 정의한다
2. 프로그램을 설계한다
3. 코드를 작성한다
4. 컴파일 한다
5. 실행시켜본다
6. 시험해보고 오류가 있다면 수정한다
7. 프로그램을 유지하고 개선해 나간다

---

## 통합 개발 환경 소개

### 프로그래밍 과정

- 소스코드 입력 → 문서 편집기 → 소스코드 → 컴파일러(+링커) → 실행 파일 → 프로그램 실행
- 소스코드는 파일의 형태로 저장
- 파일명: [기본이름].[확장자]
- 컴파일러 = 소스코드를 컴퓨터가 읽을 수 있는 형태로 바꿔줌
- 컴파일러의 목적은 실행 파일을 만들어 주는 것

**통합 개발 환경은 아주 편리하지만 눈에 보이지 않게 숨어져서 돌아가는 부분이 많다는 점이 있음**

---

## 비주얼 스튜디오 2019의 기본적인 사용법

- C는 2019, 2017, 2015 등 별 차이가 없지만 C++은 변화된 문법 때문에 호환이 안될 경우가 있다

### 프로젝트 생성하기

1. Create new Project
2. Windows Desktop Wizard
3. 프로젝트 이름과 위치 설정(이름에 의미를 부여해주는 것이 좋음)
4. 생성하고 Application type을 Console Application(문법 공부용) 설정(체크 박스 체크 X)
5. 창에 보이는 것이 없어지면 View 가서 불러와라
6. 컴파일 + 링크 = 빌드 (F7)
7. 실행하기(Ctrl + F5)

---

## C 언어와 함수

```c
int main() // 운영체제가 이 가장 큰 함수를 찾는다
{
	return 0; // 전통적으로 0을 반환하면 문제가 없다고 생각
}
```

- 우리의 프로그램이 하나의 함수
- 운영체제가 실행하는 아주 큰 함수인 것

---

## 컴파일러와 링커

### 컴파일러와 링커가 하는 일

소스코드 → 컴파일러 → 오브젝트 코드 → 링커(라이브러리 코드, 착수 코드) → 실행 파일

- 이 과정은 언어에 따라 다를 수 있음
- 라이브러리 코드 = 모든 기능을 구현할 수 없으니 자체적으로 포함된 기능
- 링커는 우리가 저걸 사용하고 싶다고 생각하고 가져다가 이어줌
- 착수start-up 코드 = 운영체제에 실행시켜 달라고 할때 기본적으로 들어가는 코드

```c
#include <stdio>  // #include <> 내가 사용하는 기능이 C표준에 있다는 것을 알고 있을 때

int main()
{
	printf("Hello, World!");

	return 0;
}
```

- 디버그 모드로 빌드 했으면 현재 .c가 있는 위치의 Debug 파일 안에 obj 파일이 있음
- exe 파일은 그 바깥에 솔루션위치의 Debug에 있음
- clean solution하면 디버그 안에 것들이 다 사라짐
- exe 파일을 직접 실행시키면 바로 꺼지게 됨(내 코드에 기다리라는 말이 없기 때문)
- 디버그 콘솔에서는 개발자가 보라고 꺼지지 않음
- Visual Studio 설치된 곳에 lib 안에 .lib 파일 안에 printf 실행할 때 필요한 머신 코드가 들어있음(링커가 링킹할 때 이것들을 넣어주는 것)

---
